<html>
	<head>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default'></script>
		<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
		<style>
			h1 {
				text-align: center;
			}

			.container {
				margin: 0 auto;
				padding: 60px 20%;
			}

			figure {
				text-align: center;
			}

			img {
				display: inline-block;
			}

			body {
				font-family: 'Inter', sans-serif;
			}
		</style>
	</head>
	<body>
		<div class="container">
		    <h1>CS184/284A Spring 2025 Homework 3 Write-Up</h1>
    <div style="text-align: center;">Name: Mark MacDermott</div>
    <br>
    <div style="text-align: center;">
        Link to webpage: <a href="https://ranototaudio.github.io/184-hw/">HW Writeups</a><br>
        Link to GitHub repository: <a href="https://github.com/RanototAudio">ranototaudio</a>
    </div>

    <figure>
        <img src="def.jpg" alt="rano" style="width:50%"/>
    </figure>

		<!--
		We've already added one heading per part, to make your write-up as navigable when grading. Please fit your write-up within these sections!
		-->

		<h2>Overview</h2>
		Give a high-level overview of what you implemented in this homework. Think about what you've built as a whole. Share your thoughts on what interesting things you've learned from completing the homework.

		<h2>Part 1: Ray Generation and Scene Intersection</h2>

		<p> 
		As part of tasks 1.1 and 1.2 I implemented a process for generating rays which are sent from the camera through points located within a single pixel.
		The first function I implemented was generate_ray(double x, double y) which takes in a normalized (x,y) ∈ [0,1] x [0,1] coordinate and outputs a ray in world space.
		Some brief definitions to serve as reminders:
		</p>

		<ul>
			<li>Image Space: 2D discrete coordinate system corresponding to pixel indices on the rendered image (e.g., (x,y) in pixel units).</li>
			<li>Camera Space: 3D coordinate system with the camera at the origin, camera axes aligned with its orientation. Used for projecting world-space geometry into a view-dependent frame.</li>
			<li>World Space: 3D global coordinate system defining absolute positions and orientations of all objects and the camera. Used as the primary reference for scene construction and object placement.</li>
			<li>Screen Space – A 2D coordinate system representing positions on the camera’s projection plane (sensor or virtual film) in the camera’s local coordinate frame. It is derived by projecting 3D points onto a canonical plane (usually 1 unit away from the pinhole along the camera’s -z axis). Unlike image space, which uses normalized pixel indices, screen space uses physical or frustum-relative coordinates [−tan⁡(hFov/2),+tan⁡(hFov/2)] directly tied to the camera’s field of view.</li>
		</ul> 

		<p>
		We first transform the image coordinates to screen space which exists within camera space, generate the ray in the camera space, and finally transform it into a ray in the world space.
		So to start we calculate the bounds of screen space and then use linear interpolation to calculate our new position.
		The horizontal/vertical field of view (hFov, vFov) define how wide/tall the camera’s frustum is.
		We convert the given hFov and vFov from degrees to radians for tan calculation.
		Finally the Z-coordinate for our final point is set at -1.0 because the screen exists as a plane.
		Thus (x, y) ∈ [0,1] is remapped to physical sensor coordinates ∈ [xmin, xmax] × [ymin, ymax]:
		</p>

		<pre><code>
		// map to screen
		double hFov_rad = hFov * PI / 180.0;
		double vFov_rad = vFov * PI / 180.0;

		double xmin = -tan(0.5 * hFov_rad);
		double xmax = tan(0.5 * hFov_rad);
		double ymin = -tan(0.5 * vFov_rad);
		double ymax = tan(0.5 * vFov_rad);

		double X_cam = xmin + (xmax - xmin) * x;
		double Y_cam = ymin + (ymax - ymin) * y;
		Vector3D P_cam(X_cam, Y_cam, -1.0);
		</code></pre>

		<p>
		Now that we have our point in screen space we are able to compute the ray in camera space simply by taking the unit vector of P_cam.
		We finally map the camera space view vector to world space using the provided c2w matrix. 
		The c2w columns are the camera’s basis vectors in world space (u, v, w)
		w is the forward view direction and points to the middle of screen space.
		u is the camera's right vector perpendicular to both w and v.
		v is the up vector relative to the camera.
		</p>

		<pre><code>
		//compute view direction
		Vector3D v_cam = P_cam.unit();

		//map to worldspace
		Vector3D v_world = (P_cam.x * c2w[0]) + (P_cam.y * c2w[1]) + (P_cam.z * c2w[2]);
		</code></pre>

		<p>
		Finally we return the Ray object with correct parameters. 
		nclip and fclip are both greater than zero and represent the so-called near and far clipping planes. 
		We consider everything that lies outside these two clipping planes invisible to the camera.
		this-> = o and v_world = d.
		</p>

		<pre><code>
		//construct ray
		Ray newRay = Ray(this->pos, v_world);
		newRay.min_t = this->nClip;
		newRay.max_t = this->fClip;

		return newRay;
		</code></pre>

		<p>
		The second function I implemented was raytrace_pixel() which estimates the radiance (color) for a single pixel (x, y) by Monte Carlo path tracing.
		It does this through the following steps. First generating multiple rays through that pixel at randomized positions.
		Second tracing each ray into the scene to estimate incoming light via global illumination.
		Third averaging the contributions of all samples to get the pixel’s final color.
		</p>

		<pre><code>
		int num_samples = ns_aa;
		Vector3D sum(0.0, 0.0, 0.0);
		
		for (int i = 0; i < num_samples; i++) {
			double x_norm = (x + gridSampler->get_sample().x) / sampleBuffer.w;
			double y_norm = (y + gridSampler->get_sample().y) / sampleBuffer.h;

			sum += est_radiance_global_illumination(camera->generate_ray(x_norm, y_norm));

		}
		sum = sum / num_samples;
		sampleBuffer.update_pixel(sum, x, y);
		</code></pre>

		
		<p><strong>Rendering Equation:</strong></p>
		<p>
		\[
		L_o(p, \omega_o) = L_e(p, \omega_o) +
		\int_{\Omega} f_r(p, \omega_i, \omega_o)\, L_i(p, \omega_i)\, \cos\theta_i \, d\omega_i
		\]
		This is implemented via est_radiance_global_illumination()
		</p>

		<p><strong>Monte Carlo Estimator:</strong></p>
		<p>
		\[
		\hat{L}_o(p, \omega_o) =
		\frac{1}{N} \sum_{i=1}^N
		\frac{f_r(p, \omega_i, \omega_o)\, L_i(p, \omega_i)\, \cos\theta_i}{p(\omega_i)}
		\]
		This is implemented via summing and averaging the radiance values returned.
		</p>

		<p>
		Next I implemented Triangle::has_intersection(...) and Triangle::intersect(...)
		The ray equation is defined as follows: r(t) = o + td. r(t) is a point along the ray at timestop t.
		o is the origin or start position of the ray at timestop zero. d is a vector representing the direction that the ray travels from the origin.
		In order to solve for t, the time at which the ray intersects the triangle, we will use the Möller–Trumbore Algorithm.
		The Möller–Trumbore algorithm solves the ray-triangle intersection analytically by expressing the intersection point in terms of barycentric coordinates.
		</p>

		<p>
		Given a triangle defined by vertices \(P_0\), \(P_1\), and \(P_2\), we can express any point
		within the triangle using <strong>barycentric coordinates</strong>:
		</p>

		<p>
		\[
		P = \alpha P_0 + \beta P_1 + \gamma P_2
		\]
		</p>

		<p>
		We define:
		\[
		b_1 = \beta, \quad b_2 = \gamma, \quad \alpha = 1 - b_1 - b_2
		\]
		</p>

		<p>
		Substituting \(\alpha\):
		\[
		P = (1 - b_1 - b_2)P_0 + b_1 P_1 + b_2 P_2
		\]
		</p>

		<p>
		The ray equation is:
		\[
		r(t) = O + tD
		\]
		Substitute \(P = r(t)\):
		\[
		O + tD = (1 - b_1 - b_2)P_0 + b_1 P_1 + b_2 P_2
		\]
		</p>

		<p>
		Rearrange:
		\[
		O - P_0 = -tD + b_1 (P_1 - P_0) + b_2 (P_2 - P_0)
		\]
		</p>

		<p>
		Expressed in matrix form:
		</p>

		<p>
		\[
		\begin{bmatrix}
		- D & P_1 - P_0 & P_2 - P_0
		\end{bmatrix}
		\begin{bmatrix}
		t \\[4pt]
		b_1 \\[4pt]
		b_2
		\end{bmatrix}
		=
		O - P_0
		\]
		</p>

		<p>
		For a system \(M x = b\), Cramer’s rule gives:
		</p>

		<p>
		\[
		x =
		\frac{1}{|M|}
		\begin{bmatrix}
		|M_1| \\[4pt]
		|M_2| \\[4pt]
		|M_3|
		\end{bmatrix}
		\]
		</p>

		<p>
		where \(M_i\) is matrix \(M\) with its \(i\)-th column replaced by \(b\).
		</p>

		<p>
		Define the helper vectors:
		</p>

		<p>
		\[
		\begin{aligned}
		S &= O - P_0 \\[4pt]
		S_1 &= D \times E_2 \\[4pt]
		S_2 &= S \times E_1
		\end{aligned}
		\]
		</p>

		<p>
		The determinant of \(M\) is:
		\[
		|M| = S_1 \cdot E_1
		\]
		</p>

		<p>
		Substitute into Cramer’s rule to directly solve for \(t, b_1, b_2\):
		</p>

		<p>
		\[
		\begin{bmatrix}
		t \\[4pt]
		b_1 \\[4pt]
		b_2
		\end{bmatrix}
		=
		\frac{1}{S_1 \cdot E_1}
		\begin{bmatrix}
		S_2 \cdot E_2 \\[4pt]
		S_1 \cdot S \\[4pt]
		S_2 \cdot D
		\end{bmatrix}
		\]
		</p>


		<p>
		A valid intersection occurs if:
		</p>

		<p>
		\[
		\begin{aligned}
		& b_1 \ge 0, \\
		& b_2 \ge 0, \\
		& b_1 + b_2 \le 1, \\
		& t \ge 0
		\end{aligned}
		\]
		</p>

		<p>
		This code is simply an implemention of the process.
		</p>

		<pre><code>
			Vector3D E1 = p2 - p1;
			Vector3D E2 = p3 - p1;
			Vector3D S = r.o - p1;
			Vector3D S1 = cross(r.d, E2);
			Vector3D S2 = cross(S, E1);

			Vector3D sols(dot(S2, E2), dot(S1, S), dot(S2, r.d));
			sols = (1.0 / dot(S1, E1)) * sols;

			double t = sols[0];
			double b1 = sols[1];
			double b2 = sols[2];

			// t within range and barycentric coordinates valid
			if (t > r.min_t && t < r.max_t && b1 >= 0 && b2 >= 0 && (b1 + b2) <= 1) {
			r.max_t = t;
			isect->t = t;
			isect->bsdf = get_bsdf();
			isect->primitive = this;
			isect->n = ((1 - b1 - b2) * n1 + b1 * n2 + b2 * n3).unit();
			return true;
			}
			return false;
			}
		</code></pre>

		<p>
		Finally I implemented the ray sphere intersection, Sphere::has_intersection(...) and Sphere::intersect(...). 
		For any point p on a sphere's surface, the following equation is satisfied.
		(p - c)^2 - R^2 = 0 where c is the center of the sphere and R is the radius. Using this we can substitue r(t) for p.
		We get (o + t d - c)^2 - R^2 = 0. If we expand this expression and analyze it as a quadratic at2 + bt + c = 0 we obtain the following coefficients.
		a = d · d
		b = 2(o - c) · d
		c = (o - c) · (o - c) - R
		Finally we can solve for t simply by using the quadratic formula. 
		</p>
		
		<h2>Part 2: Bounding Volume Hierarchy</h2>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<h2>Part 3: Direct Illumination</h2>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<h2>Part 4: Global Illumination</h2>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<h2>Part 5: Adaptive Sampling</h2>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		
		<div style="display: flex; flex-direction: column; align-items: center;">
		<table style="width: 100%; text-align: center; border-collapse: collapse;">
		<tr>
		<td style="text-align: center;">
		<img src="cornell.png" width="400px"/>
		<figcaption>Caption goes here.</figcaption>
		</td>
		<td style="text-align: center;">
		<img src="cornell.png" width="400px"/>
		<figcaption>Caption goes here.</figcaption>
		</td>
		</tr>
		<tr>
		<td style="text-align: center;">
		<img src="cornell.png" width="400px"/>
		<figcaption>Caption goes here.</figcaption>
		</td>
		<td style="text-align: center;">
		<img src="cornell.png" width="400px"/>
		<figcaption>Caption goes here.</figcaption>
		</td>
		</tr>
		</table>
		</div>

		</div>
	</body>
</html>